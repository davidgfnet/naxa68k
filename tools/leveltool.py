#!/usr/bin/env python3

# Filename  : leveltool.py
# Authors   : David Guillen Fandos
# Version   : 0.1
# Date      : June 1, 2019
# Copyright : Public Domain

from PIL import Image
import os, sys, hashlib, math, xmltodict, argparse
from common import *

parser = argparse.ArgumentParser(prog='leveltool')
parser.add_argument('--level', dest='levelfile', required=True, help='Level file (TMX format)')
parser.add_argument('--outfile', dest='outfile', required=True, help='Output file (.c/.h format)')
parser.add_argument('--compact', dest='compact', type=bool, default=True, help='Tile format is compact [256 tiles]')
parser.add_argument('--basename', dest='basename', required=True, help='Variable base name')
args = parser.parse_args()

PLANE_NAMES = ["PlaneA_Low", "PlaneA_High", "PlaneB_Low", "PlaneB_High"]

# Reads a level in TMX format (XML) and parses it to a level.
# It will also read tilesets referenced from it.

N = 8   # pixels per tile
tmx = TMXMap(args.levelfile)

# Expand the tiles into a unified tileset map
ubertileset = {}
for _, _, _, s in tmx._tilesets:
	ubertileset.update(s)

outc = open(args.outfile, "w")
outc.write("// Autogenerated from %s by leveltool.py\n\n" % args.levelfile)
outc.write("//#include <stdint.h>\n\n")

# Find the collision layer and output it in a 1-bit/block format for easy lookup
# TODO: Implement better tiles, perhaps also 16x16 blocks too.
if "collision" in tmx._layers:
	outc.write(tmx.collLayer(tmx._layers["collision"], "collision"))

# Now output all the layers
usedtiles, allused = {}, set()
for pname in [x.lower() for x in PLANE_NAMES]:
	if pname not in tmx._layers:
		continue
	pal_slot = int(tmx._layers[pname][3].get("pal_slot", "0"))
	print("Processing tiles for", pname, "with palette", pal_slot)

	# We just read all the tiles
	usedtiles[pal_slot] = usedtiles.get(pal_slot, set())
	for row in tmx._layers[pname][2]:
		for tn in row:
			usedtiles[pal_slot].add(tn)
			allused.add(tn)

print("Number of unique used tiles: %d" % len(allused))

# Calculate the (up to) four palettes
# Assuming each layer has a palette of 15+1 colors, calculate it now.
palettes = {n: set([0x200]) for n in usedtiles}
for palnum, tileset in usedtiles.items():
	for tn in tileset:
		tile = ubertileset[tn]
		palettes[palnum] |= set(image9b(tile))  # Get all possible colors

for palnum, pal in palettes.items():
	if len(pal) > 16:
		print("Palette num %d has too many colours" % palnum)
		sys.exit(1)
	else:
		print("Palette num %s has %d colors" % (palnum, len(pal)))

# Group tiles by palettes, using the palete attribute or assume
# it's 0 if not specified (for like single plane levels).

# Sort palettes to some sort of order, make transparent the first color :)
palettes = {k: sorted(v, reverse=True) for k, v in palettes.items()}

# Take all the tiles by each palette and output them.
print("Creating tile set")
transl, count = {}, 0
outc.write("static const uint32_t %s_tiles[%d * 8] = {\n" % (args.basename, sum(len(x) for x in usedtiles.values())))
for palnum, ts in usedtiles.items():
	p = palettes[palnum]
	transl[palnum] = {}
	for tn in ts:
		transl[palnum][tn] = count
		count += 1
		tileim = map2pal(image9b(ubertileset[tn]), p)
		words = []
		for i in range(0, 64, 8):
			words.append(0)
			for j in range(8):
				words[-1] |= (tileim[i+j] << (28 - j*4))
		outc.write(",".join([hex(x) for x in words]) + ",\n")

outc.write("};\n")
outc.write("#define %s_tiles_count (%d)\n\n" % ((args.basename, count)))

# Now we output all the layers as tilemaps
print("Creating tile maps")
if args.compact:
	for pname in [x.lower() for x in PLANE_NAMES if x.lower() in tmx._layers]:
		l = tmx._layers[pname]
		pal_slot = int(l[3].get("pal_slot", "0"))
		outc.write("static const uint16_t %s_tilemap_%s[%d][%d] = {\n" % (args.basename, pname, l[1], l[0]))
		for row in l[2]:
			outc.write("{" + ",".join([str(transl[pal_slot][x]) for x in row]) + "},\n")
		outc.write("};\n")
		outc.write("#define %s_tilemap_%s_count (sizeof(%s_tilemap_%s) / sizeof(%s_tilemap_%s[0]))\n" % (
			(args.basename, pname, args.basename, pname, args.basename, pname)))
		outc.write("#define %s_tilemap_%s_width (%d)\n" % (args.basename, pname, l[0]))
		outc.write("#define %s_tilemap_%s_height (%d)\n\n" % (args.basename, pname, l[1]))
else:
	raise ValueError("Cant handle yet")

print("Creating palettes")
for pname, pal in palettes.items():
	outc.write("static const uint16_t palette_%s[8][16] = {\n" % pname)
	for i in range(8):
		fpal = [col9fade(c, 1 - i * 1.0/8) for c in pal]
		outc.write("{" + ",".join(["0x%x" % c for c in pal2gen(fpal)]) + "},\n")
	outc.write("};\n")

outc.close()


